apply plugin: "groovy"
apply plugin: 'application'
apply plugin: "jacoco"

sourceCompatibility = '1.8'
description = "Jenkins Jobs using groovy"
mainClassName="jdsl"

sourceSets {
    main {
        groovy {
            //noinspection GroovyAssignabilityCheck
            srcDir 'dsl'
            //noinspection GroovyAssignabilityCheck
            srcDir 'src/main'
        }
    }
}

repositories {
    maven { url 'https://repo.jenkins-ci.org/releases' }
    maven { url 'https://repo.jenkins-ci.org/public' }
    mavenCentral()
}

dependencies {
    compile "org.codehaus.groovy:groovy:2.4.5"
    compile 'javax.servlet:javax.servlet-api:3.1.0'
    compile 'org.objenesis:objenesis:2.2'
    compile group: 'cglib', name: 'cglib', version: '3.2.4'
    compile 'cglib:cglib-nodep:2.2'
    compile group: 'org.spockframework', name: 'spock-core', version: '1.1-groovy-2.4-rc-2'
    compile 'org.reflections:reflections:0.9.11'
    compile('org.eclipse.hudson:hudson-core:3.3.0') {
        exclude group: 'org.eclipse.hudson'
        exclude module: 'hudson-remoting'
    }

    compile group: 'org.jenkins-ci.main', name: 'jenkins-core', version: '2.99'
    compile group: 'org.jenkins-ci.plugins', name: 'job-dsl-core', version: '1.66'
    compile group: 'org.jenkins-ci.plugins', name: 'ssh-slaves', version: '1.25'


    testCompile group: 'org.spockframework', name: 'spock-core', version: '1.0-groovy-2.4'
}


ext {
    limits = [
            'instruction': 60,
            'branch'     : 60,
            'line'       : 60,
            'complexity' : 60,
            'method'     : 60,
            'class'      : 60
    ]
}


jacocoTestReport {
    reports {
        xml.enabled = true
        csv.enabled = false
        html.destination(new File("${buildDir}/jacocoHtml"))
    }
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: ['pipeline', '*.class'])
        })
    }
    doLast {
        def report = file("${jacoco.reportsDir}/test/jacocoTestReport.xml")
        logger.lifecycle("Checking coverage results: ${report}")

        def parser = new XmlParser()
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        def results = parser.parse(report)

        def percentage = {
            def covered = it.'@covered' as Double
            def missed = it.'@missed' as Double
            ((covered / (covered + missed)) * 100).round(2)
        }

        def counters = results.counter
        def metrics = [:]
        metrics << [
                'instruction': percentage(counters.find { (it.'@type' == 'INSTRUCTION') }),
                //'branch'     : percentage(counters.find { (it.'@type' == 'BRANCH') }),
                'line'       : percentage(counters.find { (it.'@type' == 'LINE') }),
                'complexity' : percentage(counters.find { (it.'@type' == 'COMPLEXITY') }),
                'method'     : percentage(counters.find { (it.'@type' == 'METHOD') }),
                'class'      : percentage(counters.find { (it.'@type' == 'CLASS') })
        ]


        def failures = []
        metrics.each {
            def limit = limits[it.key]
            if (it.value < limit) {
                failures.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
            }
        }

        if (failures) {
            logger.quiet("------------------ Code Coverage Failed -----------------------")
            failures.each {
                logger.quiet(it.toString())
            }
            logger.quiet("---------------------------------------------------------------")
            throw new GradleException("Code coverage failed")
        } else {
            logger.quiet("Passed Code Coverage Checks")
        }
    }
}
check.dependsOn jacocoTestReport
